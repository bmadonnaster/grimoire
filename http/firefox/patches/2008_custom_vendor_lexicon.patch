# HG changeset patch
# Parent  b060564081862e54ec7058fd4c8614709a3c8f0f
Add support for custom vendors, as in "x86_64-gentoo-linux-musl".

diff --git a/third_party/rust/target-lexicon/.cargo-checksum.json b/third_party/rust/target-lexicon/.cargo-checksum.json
--- a/third_party/rust/target-lexicon/.cargo-checksum.json
+++ b/third_party/rust/target-lexicon/.cargo-checksum.json
@@ -1,1 +1,1 @@
-{"files":{"Cargo.lock":"75d1f84b3d9e98d87e2f74984f7d032f5b28d7610cccf5e13977367189a77acd","Cargo.toml":"fe18dc2e0c86e6b28ed0244ced50e26f481087c693cb7cc1ff3062929894b0d4","LICENSE":"268872b9816f90fd8e85db5a28d33f8150ebb8dd016653fb39ef1f94f2686bc5","README.md":"c3467056d91be3f59562158ee9604c729b5b5f473efbefb036032803eb76809e","build.rs":"a9f00c32de64b949c3bb23442304fc7943154efcc831aa0d87c9b83247e4e28a","examples/host.rs":"503bafddfb372123fe4dc0e7b8037808beb5bfe6df60c00d3315922bd3792c6c","examples/misc.rs":"49a579845450b7b020ed5c97dca142fc548725893cbc82f6f750ee0caab2beca","host.rs":"4ef91a2c26405151454c2695dc0a7f455374207900ea6814d4eafdfef5f7b630","newlist":"89564342916321c5bc35e772d374a7f0af22cc9ae6dcc0027eca48d2269f18cb","sorted.txt":"5548c14054ea61b51e2d8a495da662546523c3c13e8f742f6dd57754e11f46b5","src/host.rs":"fb543df4f362e9119a58523563e453110f4e3a426f0995911d0ca386657cf1d9","src/lib.rs":"5ad3a9418a6cb52cacc0a662645ccc671c326df954671b5ec0db667653dd125a","src/parse_error.rs":"f6689a741589ca8e659b1639728696f987c9da4948701f3b7ab6dc3e35754dab","src/targets.rs":"81320bd0280c96846a328689afe22be283cb7df9c37f005ff693ee1834b345a8","src/triple.rs":"ae2895bb2ee8451b90aa6e92d7fbf24c021230416fef030fb6ad0ef051c786c3","test.sh":"40761ee2ab0b361bdce4dc17708e671f32661f62cb56a45724d60510f9498b74"},"package":"7975cb2c6f37d77b190bc5004a2bb015971464756fde9514651a525ada2a741a"}
\ No newline at end of file
+{"files":{"Cargo.lock":"75d1f84b3d9e98d87e2f74984f7d032f5b28d7610cccf5e13977367189a77acd","Cargo.toml":"fe18dc2e0c86e6b28ed0244ced50e26f481087c693cb7cc1ff3062929894b0d4","LICENSE":"268872b9816f90fd8e85db5a28d33f8150ebb8dd016653fb39ef1f94f2686bc5","README.md":"c3467056d91be3f59562158ee9604c729b5b5f473efbefb036032803eb76809e","build.rs":"8fad88eb56ac757d5a8e115b136f2bfb497b762e0ff10f7e587b99fd5a5cfe4f","examples/host.rs":"503bafddfb372123fe4dc0e7b8037808beb5bfe6df60c00d3315922bd3792c6c","examples/misc.rs":"49a579845450b7b020ed5c97dca142fc548725893cbc82f6f750ee0caab2beca","host.rs":"4ef91a2c26405151454c2695dc0a7f455374207900ea6814d4eafdfef5f7b630","newlist":"89564342916321c5bc35e772d374a7f0af22cc9ae6dcc0027eca48d2269f18cb","sorted.txt":"5548c14054ea61b51e2d8a495da662546523c3c13e8f742f6dd57754e11f46b5","src/host.rs":"fb543df4f362e9119a58523563e453110f4e3a426f0995911d0ca386657cf1d9","src/lib.rs":"2acf0373ad7d4b23753f1cf24889f4d4ccd709b277f15dfc3e5d81804d1da0f2","src/parse_error.rs":"f6689a741589ca8e659b1639728696f987c9da4948701f3b7ab6dc3e35754dab","src/targets.rs":"50b491ef337676a7b593af7243d799ee96b1b5a9a21d060a0750a674e65826a3","src/triple.rs":"780bc76830fbdafc6682b4290d07eabeacb3572b608739688b0b681e800d78e8","test.sh":"40761ee2ab0b361bdce4dc17708e671f32661f62cb56a45724d60510f9498b74"},"package":"7975cb2c6f37d77b190bc5004a2bb015971464756fde9514651a525ada2a741a"}
diff --git a/third_party/rust/target-lexicon/build.rs b/third_party/rust/target-lexicon/build.rs
--- a/third_party/rust/target-lexicon/build.rs
+++ b/third_party/rust/target-lexicon/build.rs
@@ -32,16 +32,17 @@ mod parse_error {
         UnrecognizedOperatingSystem(String),
         UnrecognizedEnvironment(String),
         UnrecognizedBinaryFormat(String),
         UnrecognizedField(String),
         NoneWithoutBinaryFormat,
     }
 }
 
+use self::targets::Vendor;
 use self::triple::{Endianness, PointerWidth, Triple};
 
 /// Assuming `target` is a path to a custom target json config file, open it
 /// and build a `Triple` using its contents.
 fn read_target_from_file(path: &Path) -> Triple {
     let mut file = File::open(path).expect("error opening target file");
     let mut json = String::new();
     file.read_to_string(&mut json)
@@ -124,25 +125,27 @@ fn write_host_rs(mut out: File, triple: 
     // The generated Debug implementation for the inner architecture variants
     // doesn't print the enum name qualifier, so import them here. There
     // shouldn't be any conflicts because these enums all share a namespace
     // in the triple string format.
     writeln!(out, "#[allow(unused_imports)]")?;
     writeln!(out, "use crate::Aarch64Architecture::*;")?;
     writeln!(out, "#[allow(unused_imports)]")?;
     writeln!(out, "use crate::ArmArchitecture::*;")?;
+    writeln!(out, "#[allow(unused_imports)]")?;
+    writeln!(out, "use crate::CustomVendor;")?;
     writeln!(out)?;
     writeln!(out, "/// The `Triple` of the current host.")?;
     writeln!(out, "pub const HOST: Triple = Triple {{")?;
     writeln!(
         out,
         "    architecture: Architecture::{:?},",
         triple.architecture
     )?;
-    writeln!(out, "    vendor: Vendor::{:?},", triple.vendor)?;
+    writeln!(out, "    vendor: {},", vendor_display(&triple.vendor))?;
     writeln!(
         out,
         "    operating_system: OperatingSystem::{:?},",
         triple.operating_system
     )?;
     writeln!(
         out,
         "    environment: Environment::{:?},",
@@ -162,17 +165,17 @@ fn write_host_rs(mut out: File, triple: 
     writeln!(out, "        Architecture::{:?}", triple.architecture)?;
     writeln!(out, "    }}")?;
     writeln!(out, "}}")?;
     writeln!(out)?;
 
     writeln!(out, "impl Vendor {{")?;
     writeln!(out, "    /// Return the vendor for the current host.")?;
     writeln!(out, "    pub const fn host() -> Self {{")?;
-    writeln!(out, "        Vendor::{:?}", triple.vendor)?;
+    writeln!(out, "        {}", vendor_display(&triple.vendor))?;
     writeln!(out, "    }}")?;
     writeln!(out, "}}")?;
     writeln!(out)?;
 
     writeln!(out, "impl OperatingSystem {{")?;
     writeln!(
         out,
         "    /// Return the operating system for the current host."
@@ -210,17 +213,21 @@ fn write_host_rs(mut out: File, triple: 
     writeln!(out, "    /// Return the triple for the current host.")?;
     writeln!(out, "    pub const fn host() -> Self {{")?;
     writeln!(out, "        Self {{")?;
     writeln!(
         out,
         "            architecture: Architecture::{:?},",
         triple.architecture
     )?;
-    writeln!(out, "            vendor: Vendor::{:?},", triple.vendor)?;
+    writeln!(
+        out,
+        "            vendor: {},",
+        vendor_display(&triple.vendor)
+    )?;
     writeln!(
         out,
         "            operating_system: OperatingSystem::{:?},",
         triple.operating_system
     )?;
     writeln!(
         out,
         "            environment: Environment::{:?},",
@@ -232,8 +239,18 @@ fn write_host_rs(mut out: File, triple: 
         triple.binary_format
     )?;
     writeln!(out, "        }}")?;
     writeln!(out, "    }}")?;
     writeln!(out, "}}")?;
 
     Ok(())
 }
+
+fn vendor_display(vendor: &Vendor) -> String {
+    match vendor {
+        Vendor::Custom(custom) => format!(
+            "Vendor::Custom(CustomVendor::Static({:?}))",
+            custom.as_str()
+        ),
+        known => format!("Vendor::{:?}", known),
+    }
+}
diff --git a/third_party/rust/target-lexicon/src/lib.rs b/third_party/rust/target-lexicon/src/lib.rs
--- a/third_party/rust/target-lexicon/src/lib.rs
+++ b/third_party/rust/target-lexicon/src/lib.rs
@@ -26,12 +26,12 @@ mod host;
 mod parse_error;
 mod targets;
 #[macro_use]
 mod triple;
 
 pub use self::host::HOST;
 pub use self::parse_error::ParseError;
 pub use self::targets::{
-    Aarch64Architecture, Architecture, ArmArchitecture, BinaryFormat, Environment, OperatingSystem,
-    Vendor,
+    Aarch64Architecture, Architecture, ArmArchitecture, BinaryFormat, CustomVendor, Environment,
+    OperatingSystem, Vendor,
 };
 pub use self::triple::{CallingConvention, Endianness, PointerWidth, Triple};
diff --git a/third_party/rust/target-lexicon/src/targets.rs b/third_party/rust/target-lexicon/src/targets.rs
--- a/third_party/rust/target-lexicon/src/targets.rs
+++ b/third_party/rust/target-lexicon/src/targets.rs
@@ -1,12 +1,15 @@
 // This file defines all the identifier enums and target-aware logic.
 
 use crate::triple::{Endianness, PointerWidth, Triple};
+use alloc::boxed::Box;
+use alloc::string::String;
 use core::fmt;
+use core::hash::{Hash, Hasher};
 use core::str::FromStr;
 
 /// The "architecture" field, which in some cases also specifies a specific
 /// subarchitecture.
 #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
 #[allow(missing_docs)]
 pub enum Architecture {
     Unknown,
@@ -285,32 +288,74 @@ impl Aarch64Architecture {
     pub fn endianness(self) -> Endianness {
         match self {
             Aarch64Architecture::Aarch64 => Endianness::Little,
             Aarch64Architecture::Aarch64be => Endianness::Big,
         }
     }
 }
 
+/// A string for a `Vendor::Custom` that can either be used in `const`
+/// contexts or hold dynamic strings.
+#[derive(Clone, Debug, Eq)]
+pub enum CustomVendor {
+    /// An owned `String`. This supports the general case.
+    Owned(Box<String>),
+    /// A static `str`, so that `CustomVendor` can be constructed in `const`
+    /// contexts.
+    Static(&'static str),
+}
+
+impl CustomVendor {
+    /// Extracts a string slice.
+    pub fn as_str(&self) -> &str {
+        match self {
+            CustomVendor::Owned(s) => s,
+            CustomVendor::Static(s) => s,
+        }
+    }
+}
+
+impl PartialEq for CustomVendor {
+    fn eq(&self, other: &Self) -> bool {
+        self.as_str() == other.as_str()
+    }
+}
+
+impl Hash for CustomVendor {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        self.as_str().hash(state)
+    }
+}
+
 /// The "vendor" field, which in practice is little more than an arbitrary
 /// modifier.
-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
+#[derive(Clone, Debug, PartialEq, Eq, Hash)]
 #[allow(missing_docs)]
 pub enum Vendor {
     Unknown,
     Amd,
     Apple,
     Experimental,
     Fortanix,
     Nvidia,
     Pc,
     Rumprun,
     Sun,
     Uwp,
     Wrs,
+
+    /// A custom vendor. "Custom" in this context means that the vendor is
+    /// not specifically recognized by upstream Autotools, LLVM, Rust, or other
+    /// relevant authorities on triple naming. It's useful for people building
+    /// and using locally patched toolchains.
+    ///
+    /// Outside of such patched environments, users of `target-lexicon` should
+    /// treat `Custom` the same as `Unknown` and ignore the string.
+    Custom(CustomVendor),
 }
 
 /// The "operating system" field, which sometimes implies an environment, and
 /// sometimes isn't an actual operating system.
 #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
 #[allow(missing_docs)]
 pub enum OperatingSystem {
     Unknown,
@@ -710,16 +755,17 @@ impl fmt::Display for Vendor {
             Vendor::Experimental => "experimental",
             Vendor::Fortanix => "fortanix",
             Vendor::Nvidia => "nvidia",
             Vendor::Pc => "pc",
             Vendor::Rumprun => "rumprun",
             Vendor::Sun => "sun",
             Vendor::Uwp => "uwp",
             Vendor::Wrs => "wrs",
+            Vendor::Custom(ref name) => name.as_str(),
         };
         f.write_str(s)
     }
 }
 
 impl FromStr for Vendor {
     type Err = ();
 
@@ -731,17 +777,54 @@ impl FromStr for Vendor {
             "experimental" => Vendor::Experimental,
             "fortanix" => Vendor::Fortanix,
             "nvidia" => Vendor::Nvidia,
             "pc" => Vendor::Pc,
             "rumprun" => Vendor::Rumprun,
             "sun" => Vendor::Sun,
             "uwp" => Vendor::Uwp,
             "wrs" => Vendor::Wrs,
-            _ => return Err(()),
+            custom => {
+                use alloc::borrow::ToOwned;
+
+                // A custom vendor. Since triple syntax is so loosely defined,
+                // be as conservative as we can to avoid potential ambiguities.
+                // We err on the side of being too strict here, as we can
+                // always relax it if needed.
+
+                // Don't allow empty string names.
+                if custom.is_empty() {
+                    return Err(());
+                }
+
+                // Don't allow any other recognized name as a custom vendor,
+                // since vendors can be omitted in some contexts.
+                if Architecture::from_str(custom).is_ok()
+                    || OperatingSystem::from_str(custom).is_ok()
+                    || Environment::from_str(custom).is_ok()
+                    || BinaryFormat::from_str(custom).is_ok()
+                {
+                    return Err(());
+                }
+
+                // Require the first character to be an ascii lowercase.
+                if !custom.chars().nth(0).unwrap().is_ascii_lowercase() {
+                    return Err(());
+                }
+
+                // Restrict the set of characters permitted in a custom vendor.
+                fn is_prohibited_char(c: char) -> bool {
+                    !(c.is_ascii_lowercase() || c.is_ascii_digit() || c == '_' || c == '.')
+                }
+                if custom.chars().any(is_prohibited_char) {
+                    return Err(());
+                }
+
+                Vendor::Custom(CustomVendor::Owned(Box::new(custom.to_owned())))
+            }
         })
     }
 }
 
 impl fmt::Display for OperatingSystem {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         let s = match *self {
             OperatingSystem::Unknown => "unknown",
@@ -1106,9 +1189,88 @@ mod tests {
             t.architecture,
             Architecture::Arm(ArmArchitecture::Thumbv7em)
         );
         assert_eq!(t.vendor, Vendor::Unknown);
         assert_eq!(t.operating_system, OperatingSystem::None_);
         assert_eq!(t.environment, Environment::Eabihf);
         assert_eq!(t.binary_format, BinaryFormat::Elf);
     }
+
+    #[test]
+    fn custom_vendors() {
+        // Test various invalid cases.
+        assert!(Triple::from_str("x86_64--linux").is_err());
+        assert!(Triple::from_str("x86_64-42-linux").is_err());
+        assert!(Triple::from_str("x86_64-__customvendor__-linux").is_err());
+        assert!(Triple::from_str("x86_64-^-linux").is_err());
+        assert!(Triple::from_str("x86_64- -linux").is_err());
+        assert!(Triple::from_str("x86_64-CustomVendor-linux").is_err());
+        assert!(Triple::from_str("x86_64-linux-linux").is_err());
+        assert!(Triple::from_str("x86_64-x86_64-linux").is_err());
+        assert!(Triple::from_str("x86_64-elf-linux").is_err());
+        assert!(Triple::from_str("x86_64-gnu-linux").is_err());
+        assert!(Triple::from_str("x86_64-linux-customvendor").is_err());
+        assert!(Triple::from_str("customvendor").is_err());
+        assert!(Triple::from_str("customvendor-x86_64").is_err());
+        assert!(Triple::from_str("x86_64-").is_err());
+        assert!(Triple::from_str("x86_64--").is_err());
+
+        // Test various Unicode things.
+        assert!(
+            Triple::from_str("x86_64-𝓬𝓾𝓼𝓽𝓸𝓶𝓿𝓮𝓷𝓭𝓸𝓻-linux").is_err(),
+            "unicode font hazard"
+        );
+        assert!(
+            Triple::from_str("x86_64-ćúśtőḿvéńdőŕ-linux").is_err(),
+            "diacritical mark stripping hazard"
+        );
+        assert!(
+            Triple::from_str("x86_64-customvendοr-linux").is_err(),
+            "homoglyph hazard"
+        );
+        assert!(Triple::from_str("x86_64-customvendor-linux").is_ok());
+        assert!(
+            Triple::from_str("x86_64-ﬃ-linux").is_err(),
+            "normalization hazard"
+        );
+        assert!(Triple::from_str("x86_64-ffi-linux").is_ok());
+        assert!(
+            Triple::from_str("x86_64-custom‍vendor-linux").is_err(),
+            "zero-width character hazard"
+        );
+
+        // Test some valid cases.
+        let t = Triple::from_str("x86_64-customvendor-linux")
+            .expect("can't parse target with custom vendor");
+        assert_eq!(t.architecture, Architecture::X86_64);
+        assert_eq!(
+            t.vendor,
+            Vendor::Custom(CustomVendor::Static("customvendor"))
+        );
+        assert_eq!(t.operating_system, OperatingSystem::Linux);
+        assert_eq!(t.environment, Environment::Unknown);
+        assert_eq!(t.binary_format, BinaryFormat::Elf);
+        assert_eq!(t.to_string(), "x86_64-customvendor-linux");
+
+        let t =
+            Triple::from_str("x86_64-customvendor").expect("can't parse target with custom vendor");
+        assert_eq!(t.architecture, Architecture::X86_64);
+        assert_eq!(
+            t.vendor,
+            Vendor::Custom(CustomVendor::Static("customvendor"))
+        );
+        assert_eq!(t.operating_system, OperatingSystem::Unknown);
+        assert_eq!(t.environment, Environment::Unknown);
+        assert_eq!(t.binary_format, BinaryFormat::Unknown);
+
+        assert_eq!(
+            Triple::from_str("unknown-foo"),
+            Ok(Triple {
+                architecture: Architecture::Unknown,
+                vendor: Vendor::Custom(CustomVendor::Static("foo")),
+                operating_system: OperatingSystem::Unknown,
+                environment: Environment::Unknown,
+                binary_format: BinaryFormat::Unknown,
+            })
+        );
+    }
 }
diff --git a/third_party/rust/target-lexicon/src/triple.rs b/third_party/rust/target-lexicon/src/triple.rs
--- a/third_party/rust/target-lexicon/src/triple.rs
+++ b/third_party/rust/target-lexicon/src/triple.rs
@@ -303,20 +303,16 @@ mod tests {
             Triple::from_str(""),
             Err(ParseError::UnrecognizedArchitecture("".to_owned()))
         );
         assert_eq!(
             Triple::from_str("foo"),
             Err(ParseError::UnrecognizedArchitecture("foo".to_owned()))
         );
         assert_eq!(
-            Triple::from_str("unknown-foo"),
-            Err(ParseError::UnrecognizedVendor("foo".to_owned()))
-        );
-        assert_eq!(
             Triple::from_str("unknown-unknown-foo"),
             Err(ParseError::UnrecognizedOperatingSystem("foo".to_owned()))
         );
         assert_eq!(
             Triple::from_str("unknown-unknown-unknown-foo"),
             Err(ParseError::UnrecognizedEnvironment("foo".to_owned()))
         );
         assert_eq!(
