Submitted By: Ken Moffat <ken at linuxfromscratch dot org>
Date: 2018-05-02
Initial Package Version: 20180414
Upstream Status: Applied
Origin: Upstream
Description: Three fixes, cherry-picked from svn.

r47469 Fix segfault in dvipdfm-x (XeTeX) on 1/2/4-bit transparent indexed PNGs.

r47470 Support poppler-0.64.0 (this one is critical for current BLFS).

r47477 Fix a ptex regression for discontinuous kinsoku table.

NB most updates in current svn are for ongoing development.

I have ignored r47476 (m-tx-0.63a) because the announcement at CTAN says this is
a minor correction which will not be moticed on most architectures.

diff -Naur a/texk/dvipdfm-x/pngimage.c b/texk/dvipdfm-x/pngimage.c
--- a/texk/dvipdfm-x/pngimage.c	2018-02-17 08:41:35.000000000 +0000
+++ b/texk/dvipdfm-x/pngimage.c	2018-04-30 16:30:00.495894146 +0100
@@ -964,12 +964,16 @@
   png_bytep   trans;
   int         num_trans;
   png_uint_32 i;
+  png_byte    bpc, mask, shift;
 
   if (!png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS) ||
       !png_get_tRNS(png_ptr, info_ptr, &trans, &num_trans, NULL)) {
     WARN("%s: PNG does not have valid tRNS chunk but tRNS is requested.", PNG_DEBUG_STR);
     return NULL;
   }
+  bpc   = png_get_bit_depth(png_ptr, info_ptr);
+  mask  = 0xff >> (8 - bpc);
+  shift = 8 - bpc;
 
   smask = pdf_new_stream(STREAM_COMPRESS);
   dict  = pdf_stream_dict(smask);
@@ -981,7 +985,8 @@
   pdf_add_dict(dict, pdf_new_name("ColorSpace"), pdf_new_name("DeviceGray"));
   pdf_add_dict(dict, pdf_new_name("BitsPerComponent"), pdf_new_number(8));
   for (i = 0; i < width*height; i++) {
-    png_byte idx = image_data_ptr[i];
+    /* data is packed for 1/2/4 bpc formats, msb first */
+    png_byte idx = (image_data_ptr[bpc * i / 8] >> (shift - bpc * i % 8)) & mask;
     smask_data_ptr[i] = (idx < num_trans) ? trans[idx] : 0xff;
   }
   pdf_add_stream(smask, (char *)smask_data_ptr, width*height);
diff -Naur a/texk/web2c/luatexdir/image/pdftoepdf.w b/texk/web2c/luatexdir/image/pdftoepdf.w
--- a/texk/web2c/luatexdir/image/pdftoepdf.w	2018-01-17 18:00:12.000000000 +0000
+++ b/texk/web2c/luatexdir/image/pdftoepdf.w	2018-04-30 16:29:12.201899987 +0100
@@ -33,9 +33,9 @@
 
 */
 
-extern void md5(Guchar *msg, int msgLen, Guchar *digest);
+extern void md5(unsigned char *msg, int msgLen, unsigned char *digest);
 
-static GBool isInit = gFalse;
+static bool isInit = false;
 
 /* Maintain AVL tree of all PDF files for embedding */
 
@@ -366,7 +366,7 @@
     char *p;
     unsigned char c;
     size_t i, l;
-    p = string->getCString();
+    p = string->c_str();
     l = (size_t) string->getLength();
     if (pdf->cave)
         pdf_out(pdf, ' ');
@@ -412,7 +412,7 @@
     Object obj1;
     pdf_begin_array(pdf);
     for (i = 0, l = array->getLength(); i < l; ++i) {
-        obj1 = array->getNF(i);
+        obj1 = array->getNF(i).copy();
         copyObject(pdf, pdf_doc, &obj1);
     }
     pdf_end_array(pdf);
@@ -425,7 +425,7 @@
     pdf_begin_dict(pdf);
     for (i = 0, l = dict->getLength(); i < l; ++i) {
         copyName(pdf, dict->getKey(i));
-        obj1 = dict->getValNF(i);
+        obj1 = dict->getValNF(i).copy();
         copyObject(pdf, pdf_doc, &obj1);
     }
     pdf_end_dict(pdf);
@@ -468,14 +468,14 @@
         break;
     /*
     case objNum:
-        GBool isNum() { return type == objInt || type == objReal; }
+        bool isNum() { return type == objInt || type == objReal; }
         break;
     */
     case objString:
-        copyString(pdf, obj->getString());
+        copyString(pdf, (GooString *)obj->getString());
         break;
     case objName:
-        copyName(pdf, obj->getName());
+        copyName(pdf, (char *)obj->getName());
         break;
     case objNull:
         pdf_add_null(pdf);
@@ -587,11 +587,11 @@
     PDFRectangle *pagebox;
     int pdf_major_version_found, pdf_minor_version_found;
     float xsize, ysize, xorig, yorig;
-    if (isInit == gFalse) {
+    if (isInit == false) {
         if (!(globalParams))
             globalParams = new GlobalParams();
-        globalParams->setErrQuiet(gFalse);
-        isInit = gTrue;
+        globalParams->setErrQuiet(false);
+        isInit = true;
     }
     if (img_type(idict) == IMG_TYPE_PDF)
         pdf_doc = refPdfDocument(img_filepath(idict), FE_FAIL);
@@ -788,12 +788,12 @@
         Now all relevant parts of the Page dictionary are copied. Metadata validity
         check is needed(as a stream it must be indirect).
     */
-    obj1 = pageDict->lookupNF("Metadata");
+    obj1 = pageDict->lookupNF("Metadata").copy();
     if (!obj1.isNull() && !obj1.isRef())
         formatted_warning("pdf inclusion","/Metadata must be indirect object");
     /* copy selected items in Page dictionary */
     for (i = 0; pagedictkeys[i] != NULL; i++) {
-        obj1 = pageDict->lookupNF(pagedictkeys[i]);
+        obj1 = pageDict->lookupNF(pagedictkeys[i]).copy();
         if (!obj1.isNull()) {
             pdf_add_name(pdf, pagedictkeys[i]);
             /* preserves indirection */
@@ -806,13 +806,13 @@
         PDF file, climbing up the tree until the Resources are found.
         (This fixes a problem with Scribus 1.3.3.14.)
     */
-    obj1 = pageDict->lookupNF("Resources");
+    obj1 = pageDict->lookupNF("Resources").copy();
     if (obj1.isNull()) {
         op1 = &pagesobj1;
         op2 = &pagesobj2;
         *op1 = pageDict->lookup("Parent");
         while (op1->isDict()) {
-            obj1 = op1->dictLookupNF("Resources");
+            obj1 = op1->dictLookupNF("Resources").copy();
             if (!obj1.isNull()) {
                 pdf_add_name(pdf, "Resources");
                 copyObject(pdf, pdf_doc, &obj1);
@@ -966,7 +966,7 @@
     if (PdfDocumentTree != NULL)
         avl_destroy(PdfDocumentTree, destroyPdfDocument);
     PdfDocumentTree = NULL;
-    if (isInit == gTrue)
+    if (isInit == true)
         delete globalParams;
-    isInit = gFalse;
+    isInit = false;
 }
diff -Naur a/texk/web2c/luatexdir/lua/lepdflib.cc b/texk/web2c/luatexdir/lua/lepdflib.cc
--- a/texk/web2c/luatexdir/lua/lepdflib.cc	2018-02-14 14:44:38.000000000 +0000
+++ b/texk/web2c/luatexdir/lua/lepdflib.cc	2018-04-30 16:29:17.889917722 +0100
@@ -219,7 +219,6 @@
 {
     Attribute::Type t;
     const char *n;
-    int nlen;
     udstruct *uobj, *uout;
 
     if (lua_type(L,1)==LUA_TNUMBER) {
@@ -235,12 +234,11 @@
 
     } else if (lua_type(L,1)==LUA_TSTRING) {
        n = luaL_checkstring(L,1);
-       nlen = luaL_checkint(L,2);
        uobj = (udstruct *) luaL_checkudata(L, 3, M_Object);
        if (uobj->pd != NULL && uobj->pd->pc != uobj->pc)
           pdfdoc_changed_error(L);
        uout = new_Attribute_userdata(L);
-       uout->d = new Attribute(n, nlen, (Object *)uobj->d);
+       uout->d = new Attribute(GooString(n), (Object *)uobj->d);
        uout->atype = ALLOC_LEPDF;
        uout->pc = uobj->pc;
        uout->pd = uobj->pd;
@@ -439,7 +437,7 @@
       break;
     case 1:
       if (lua_isboolean (L,1)) {
-	uout->d = new Object(lua_toboolean(L, 1)? gTrue : gFalse);
+	uout->d = new Object(lua_toboolean(L, 1)? true : false);
 	uout->atype = ALLOC_LEPDF;
 	uout->pc = 0;
 	uout->pd = NULL;
@@ -496,7 +494,7 @@
 	double numA = lua_tonumber(L,1);
 	double genA = lua_tonumber(L,2);
 	if ( ((numA)==(int)(numA)) && ((genA)==(int)(genA)) ){
-	  uout->d = new Object((int)(numA), (int)(genA));
+	  uout->d = new Object((const Ref) {(int)(numA), (int)(genA)});
 	  uout->atype = ALLOC_LEPDF;
 	  uout->pc = 0;
 	  uout->pd = NULL;
@@ -674,9 +672,9 @@
     uin = (udstruct *) luaL_checkudata(L, 1, M_##in);          \
     if (uin->pd != NULL && uin->pd->pc != uin->pc)             \
         pdfdoc_changed_error(L);                               \
-    gs = ((in *) uin->d)->function();                          \
+    gs = (GooString *)((in *) uin->d)->function();             \
     if (gs != NULL)                                            \
-        lua_pushlstring(L, gs->getCString(), gs->getLength()); \
+        lua_pushlstring(L, gs->c_str(), gs->getLength()); \
     else                                                       \
         lua_pushnil(L);                                        \
     return 1;                                                  \
@@ -889,7 +887,7 @@
     if (i > 0 && i <= len) {
         uout = new_Object_userdata(L);
         uout->d = new Object();
-        *((Object *) uout->d) = ((Array *) uin->d)->getNF(i - 1);
+        *((Object *) uout->d) = ((Array *) uin->d)->getNF(i - 1).copy();
         uout->atype = ALLOC_LEPDF;
         uout->pc = uin->pc;
         uout->pd = uin->pd;
@@ -911,7 +909,7 @@
     if (i > 0 && i <= len) {
         gs = new GooString();
         if (((Array *) uin->d)->getString(i - 1, gs))
-            lua_pushlstring(L, gs->getCString(), gs->getLength());
+            lua_pushlstring(L, gs->c_str(), gs->getLength());
         else
             lua_pushnil(L);
         delete gs;
@@ -1063,7 +1061,7 @@
     if (i > 0 && i <= len) {
         gs = ((Catalog *) uin->d)->getJS(i - 1);
         if (gs != NULL)
-            lua_pushlstring(L, gs->getCString(), gs->getLength());
+            lua_pushlstring(L, gs->c_str(), gs->getLength());
         else
             lua_pushnil(L);
         delete gs;
@@ -1132,7 +1130,7 @@
         pdfdoc_changed_error(L);
     s = copyString(luaL_checkstring(L, 2));
     uobj = (udstruct *) luaL_checkudata(L, 3, M_Object);
-    ((Dict *) uin->d)->add(s, std::move(*((Object *) uobj->d)));
+    ((Dict *) uin->d)->add((const char *) s, std::move(*((Object *) uobj->d)));
     return 0;
 }
 
@@ -1190,7 +1188,7 @@
     s = luaL_checkstring(L, 2);
     uout = new_Object_userdata(L);
     uout->d = new Object();
-    *((Object *) uout->d) = ((Dict *) uin->d)->lookupNF(s);
+    *((Object *) uout->d) = ((Dict *) uin->d)->lookupNF(s).copy();
     uout->atype = ALLOC_LEPDF;
     uout->pc = uin->pc;
     uout->pd = uin->pd;
@@ -1263,7 +1261,7 @@
     if (i > 0 && i <= len) {
         uout = new_Object_userdata(L);
         uout->d = new Object();
-        *((Object *) uout->d) = ((Dict *) uin->d)->getValNF(i - 1);
+        *((Object *) uout->d) = ((Dict *) uin->d)->getValNF(i - 1).copy();
         uout->atype = ALLOC_LEPDF;
         uout->pc = uin->pc;
         uout->pd = uin->pd;
@@ -1378,7 +1376,7 @@
     uin = (udstruct *) luaL_checkudata(L, 1, M_GooString);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    lua_pushlstring(L, ((GooString *) uin->d)->getCString(),
+    lua_pushlstring(L, ((GooString *) uin->d)->c_str(),
                     ((GooString *) uin->d)->getLength());
     return 1;
 }
@@ -1527,9 +1525,9 @@
         pdfdoc_changed_error(L);
     luaL_checktype(L, 2, LUA_TBOOLEAN);
     if (lua_toboolean(L, 2) != 0)
-        *((Object *) uin->d) = Object(gTrue);
+        *((Object *) uin->d) = Object(true);
     else
-        *((Object *) uin->d) = Object(gFalse);
+        *((Object *) uin->d) = Object(false);
     return 0;
 }
 
@@ -1653,7 +1651,7 @@
         pdfdoc_changed_error(L);
     num = luaL_checkint(L, 2);
     gen = luaL_checkint(L, 3);
-    *((Object *) uin->d) = Object(num, gen);
+    *((Object *) uin->d) = Object((const Ref) {num, gen});
     return 0;
 }
 
@@ -1813,8 +1811,8 @@
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
     if (((Object *) uin->d)->isString()) {
-        gs = ((Object *) uin->d)->getString();
-        lua_pushlstring(L, gs->getCString(), gs->getLength());
+        gs = (GooString *)((Object *) uin->d)->getString();
+        lua_pushlstring(L, gs->c_str(), gs->getLength());
     } else
         lua_pushnil(L);
     return 1;
@@ -2011,7 +2009,7 @@
         if (i > 0 && i <= len) {
             uout = new_Object_userdata(L);
             uout->d = new Object();
-            *((Object *) uout->d) = ((Object *) uin->d)->arrayGetNF(i - 1);
+            *((Object *) uout->d) = ((Object *) uin->d)->arrayGetNF(i - 1).copy();
             uout->atype = ALLOC_LEPDF;
             uout->pc = uin->pc;
             uout->pd = uin->pd;
@@ -2051,7 +2049,7 @@
         pdfdoc_changed_error(L);
     if (!((Object *) uin->d)->isDict())
         luaL_error(L, "Object is not a Dict");
-    ((Object *) uin->d)->dictAdd(copyString(s), std::move(*((Object *) uobj->d)));
+    ((Object *) uin->d)->dictAdd((const char *) copyString(s), std::move(*((Object *) uobj->d)));
     return 0;
 }
 
@@ -2104,7 +2102,7 @@
     if (((Object *) uin->d)->isDict()) {
         uout = new_Object_userdata(L);
         uout->d = new Object();
-        *((Object *) uout->d) = ((Object *) uin->d)->dictLookupNF(s);
+        *((Object *) uout->d) = ((Object *) uin->d)->dictLookupNF(s).copy();
         uout->atype = ALLOC_LEPDF;
         uout->pc = uin->pc;
         uout->pd = uin->pd;
@@ -2169,7 +2167,7 @@
         if (i > 0 && i <= len) {
             uout = new_Object_userdata(L);
             uout->d = new Object();
-            *((Object *) uout->d) = ((Object *) uin->d)->dictGetValNF(i - 1);
+            *((Object *) uout->d) = ((Object *) uin->d)->dictGetValNF(i - 1).copy();
             uout->atype = ALLOC_LEPDF;
             uout->pc = uin->pc;
             uout->pd = uin->pd;
@@ -2472,7 +2470,7 @@
         pdfdoc_changed_error(L);
     gs = ((PdfDocument *) uin->d)->doc->getFileName();
     if (gs != NULL)
-        lua_pushlstring(L, gs->getCString(), gs->getLength());
+        lua_pushlstring(L, gs->c_str(), gs->getLength());
     else
         lua_pushnil(L);
     return 1;
@@ -2561,7 +2559,7 @@
     if (((PdfDocument *) uin->d)->doc->getCatalog()->isOk()) {
         gs = ((PdfDocument *) uin->d)->doc->readMetadata();
         if (gs != NULL)
-            lua_pushlstring(L, gs->getCString(), gs->getLength());
+            lua_pushlstring(L, gs->c_str(), gs->getLength());
         else
             lua_pushnil(L);
     } else
@@ -3024,12 +3022,12 @@
 
 static int m_Attribute_setRevision(lua_State * L)
 {
-    Guint i;
+    uint i;
     udstruct *uin;
     uin = (udstruct *) luaL_checkudata(L, 1, M_Attribute);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    i = (Guint) luaL_checkint(L, 2);
+    i = (uint) luaL_checkint(L, 2);
     ((Attribute *) uin->d)->setRevision(i);
     return 0;
 }
@@ -3038,12 +3036,12 @@
 
 static int m_Attribute_setHidden(lua_State * L)
 {
-    GBool i;
+    bool i;
     udstruct *uin;
     uin = (udstruct *) luaL_checkudata(L, 1, M_Attribute);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    i = (GBool) lua_toboolean(L, 2);
+    i = (bool) lua_toboolean(L, 2);
     ((Attribute *) uin->d)->setHidden(i);
     return 0;
 }
@@ -3180,7 +3178,7 @@
 // Ref is false if the C++ functione return false
 static int m_StructElement_getPageRef(lua_State * L)
 {
-    GBool b;
+    bool b;
     Ref *r;
     udstruct *uin, *uout;
     uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
@@ -3214,28 +3212,28 @@
 
 static int m_StructElement_setRevision(lua_State * L)
 {
-    Guint i;
+    uint i;
     udstruct *uin;
     uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    i = (Guint) luaL_checkint(L, 2);
+    i = (uint) luaL_checkint(L, 2);
     ((StructElement *) uin->d)->setRevision(i);
     return 0;
 }
 
 static int m_StructElement_getText(lua_State * L)
 {
-    GBool i;
+    bool i;
     GooString *gs;
     udstruct *uin;
     uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    i = (GBool) lua_toboolean(L, 2);
+    i = (bool) lua_toboolean(L, 2);
     gs =  ((StructElement *) uin->d)->getText(i);
     if (gs != NULL)
-        lua_pushlstring(L, gs->getCString(), gs->getLength());
+        lua_pushlstring(L, gs->c_str(), gs->getLength());
     else
         lua_pushnil(L);
     return 1;
@@ -3321,7 +3319,7 @@
 {
     Attribute::Type t;
     Attribute::Owner o;
-    GBool g;
+    bool g;
     udstruct *uin, *uout;
     const Attribute *a;
     uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
@@ -3329,7 +3327,7 @@
         pdfdoc_changed_error(L);
     t = (Attribute::Type) luaL_checkint(L,1);
     o = (Attribute::Owner) luaL_checkint(L,2);
-    g = (GBool) lua_toboolean(L, 3);
+    g = (bool) lua_toboolean(L, 3);
     a = ((StructElement *) uin->d)->findAttribute(t,g,o);
 
     if (a!=NULL){
diff -Naur a/texk/web2c/ptexdir/ptex_version.h b/texk/web2c/ptexdir/ptex_version.h
--- a/texk/web2c/ptexdir/ptex_version.h	2018-01-21 03:48:06.000000000 +0000
+++ b/texk/web2c/ptexdir/ptex_version.h	2018-04-30 16:27:55.978626503 +0100
@@ -1 +1 @@
-#define PTEX_VERSION "p3.8.0"
+#define PTEX_VERSION "p3.8.1"
diff -Naur a/texk/web2c/ptexdir/tests/free_ixsp.tex b/texk/web2c/ptexdir/tests/free_ixsp.tex
--- a/texk/web2c/ptexdir/tests/free_ixsp.tex	1970-01-01 01:00:00.000000000 +0100
+++ b/texk/web2c/ptexdir/tests/free_ixsp.tex	2018-04-30 16:13:49.260128806 +0100
@@ -0,0 +1,53 @@
+%#!eptex -ini -etex
+\let\dump\relax
+\batchmode
+\input plain
+
+\errorstopmode
+\catcode`@=11
+\newcount\@tempcnta
+\newcount\@tempcntb
+\newcount\@tempcntc
+\mathchardef\LIM=256
+
+\def\MYCHAR#1{%
+  \@tempcntc=\numexpr7*#1+"101\relax
+  \@tempcnta=\@tempcntc\divide\@tempcnta 94
+  \@tempcntb=\numexpr\@tempcntc-94*\@tempcnta+1\relax
+  \ifnum\@tempcntb<0\advance\@tempcntb94 \advance\@tempcnta-1\fi
+  \advance\@tempcnta18 % 18区以降
+  \CNTA=\kuten\numexpr"100*\@tempcnta+\@tempcntb\relax
+}
+
+\newcount\CNT\newcount\CNTA
+\CNT=0
+\loop
+  \MYCHAR\CNT
+  \message{\the\CNT.}
+  \inhibitxspcode\CNTA=1\relax
+  \advance\CNT1\relax
+  \ifnum\CNT<\LIM
+\repeat
+
+\newcount\CNTB
+
+\loop
+  \MYCHAR\CNTB
+  \global\inhibitxspcode\CNTA=3
+{%
+\CNT=0
+\loop
+  \MYCHAR\CNT
+  \count@=\numexpr 1-\inhibitxspcode\CNTA\relax
+  \ifnum\count@=0\else\ifnum\CNTB=\CNT\else
+    \errmessage{<\the\CNTB, \the\CNT, \the\inhibitxspcode\CNTA>}\fi\fi
+  \advance\CNT1\relax
+  \ifnum\CNT<\LIM
+\repeat
+}
+  \MYCHAR\CNTB
+  \global\inhibitxspcode\CNTA=1\relax
+  \advance\CNTB1\relax
+  \ifnum\CNTB<\LIM
+\repeat
+\bye
diff -Naur a/texk/web2c/ptexdir/tests/free_pena.tex b/texk/web2c/ptexdir/tests/free_pena.tex
--- a/texk/web2c/ptexdir/tests/free_pena.tex	1970-01-01 01:00:00.000000000 +0100
+++ b/texk/web2c/ptexdir/tests/free_pena.tex	2018-04-30 16:15:00.829396672 +0100
@@ -0,0 +1,52 @@
+%#!eptex -ini -etex
+\let\dump\relax
+\batchmode
+\input plain
+
+\errorstopmode
+\catcode`@=11
+\newcount\@tempcnta
+\newcount\@tempcntb
+\newcount\@tempcntc
+\mathchardef\LIM=256
+
+\def\MYCHAR#1{%
+  \@tempcntc=\numexpr7*#1+"101\relax
+  \@tempcnta=\@tempcntc\divide\@tempcnta 94
+  \@tempcntb=\numexpr\@tempcntc-94*\@tempcnta+1\relax
+  \ifnum\@tempcntb<0\advance\@tempcntb94 \advance\@tempcnta-1\fi
+  \advance\@tempcnta18 % 18区以降
+  \CNTA=\kuten\numexpr"100*\@tempcnta+\@tempcntb\relax
+}
+
+\newcount\CNT\newcount\CNTA
+\CNT=0
+\loop
+  \MYCHAR\CNT
+  \message{\the\CNT.}
+  \prebreakpenalty\CNTA=\numexpr\CNT+1\relax
+  \advance\CNT1\relax
+  \ifnum\CNT<\LIM
+\repeat
+
+\newcount\CNTB
+
+\loop
+  \MYCHAR\CNTB
+  \global\prebreakpenalty\CNTA=0
+{%
+\CNT=0
+\loop
+  \MYCHAR\CNT
+  \count@=\numexpr -\CNT-1+\prebreakpenalty\CNTA\relax
+  \ifnum\count@=0\else\ifnum\CNTB=\CNT\else\errmessage{<\the\CNTB, \the\CNT>}\fi\fi
+  \advance\CNT1\relax
+  \ifnum\CNT<\LIM
+\repeat
+}
+  \MYCHAR\CNTB
+  \global\prebreakpenalty\CNTA=\numexpr\CNTB+1\relax
+  \advance\CNTB1\relax
+  \ifnum\CNTB<\LIM
+\repeat
+\bye
