diff -Naupr a/tools/clang/lib/Analysis/PathDiagnostic.cpp b/tools/clang/lib/Analysis/PathDiagnostic.cpp
--- a/tools/clang/lib/Analysis/PathDiagnostic.cpp	2020-03-23 16:01:02.000000000 +0100
+++ b/tools/clang/lib/Analysis/PathDiagnostic.cpp	2020-03-29 12:33:03.894903142 +0200
@@ -676,8 +676,8 @@ PathDiagnosticLocation::create(const Pro
   } else if (Optional<PostInitializer> PIP = P.getAs<PostInitializer>()) {
     return PathDiagnosticLocation(PIP->getInitializer()->getSourceLocation(),
                                   SMng);
-  } else if (Optional<PreImplicitCall> PIC = P.getAs<PreImplicitCall>()) {
-    return PathDiagnosticLocation(PIC->getLocation(), SMng);
+  } else if (Optional<PreImplicitCall> pic = P.getAs<PreImplicitCall>()) {
+    return PathDiagnosticLocation(pic->getLocation(), SMng);
   } else if (Optional<PostImplicitCall> PIE = P.getAs<PostImplicitCall>()) {
     return PathDiagnosticLocation(PIE->getLocation(), SMng);
   } else if (Optional<CallEnter> CE = P.getAs<CallEnter>()) {
diff -Naupr a/tools/clang/lib/CodeGen/BackendUtil.cpp b/tools/clang/lib/CodeGen/BackendUtil.cpp
--- a/tools/clang/lib/CodeGen/BackendUtil.cpp	2020-03-23 16:01:02.000000000 +0100
+++ b/tools/clang/lib/CodeGen/BackendUtil.cpp	2020-03-29 12:34:16.034905411 +0200
@@ -1066,10 +1066,10 @@ void EmitAssemblyHelper::EmitAssemblyWit
   PTO.LoopVectorization = CodeGenOpts.VectorizeLoop;
   PTO.SLPVectorization = CodeGenOpts.VectorizeSLP;
 
-  PassInstrumentationCallbacks PIC;
+  PassInstrumentationCallbacks pic;
   StandardInstrumentations SI;
-  SI.registerCallbacks(PIC);
-  PassBuilder PB(TM.get(), PTO, PGOOpt, &PIC);
+  SI.registerCallbacks(pic);
+  PassBuilder PB(TM.get(), PTO, PGOOpt, &pic);
 
   // Attempt to load pass plugins and register their callbacks with PB.
   for (auto &PluginFN : CodeGenOpts.PassPlugins) {
diff -Naupr a/tools/clang/lib/Driver/ToolChains/CommonArgs.cpp b/tools/clang/lib/Driver/ToolChains/CommonArgs.cpp
--- a/tools/clang/lib/Driver/ToolChains/CommonArgs.cpp	2020-03-23 16:01:02.000000000 +0100
+++ b/tools/clang/lib/Driver/ToolChains/CommonArgs.cpp	2020-03-29 12:32:15.198234939 +0200
@@ -890,11 +890,11 @@ tools::ParsePICArgs(const ToolChain &Too
   const llvm::Triple &Triple = ToolChain.getTriple();
 
   bool PIE = ToolChain.isPIEDefault();
-  bool PIC = PIE || ToolChain.isPICDefault();
+  bool pic = PIE || ToolChain.isPICDefault();
   // The Darwin/MachO default to use PIC does not apply when using -static.
   if (Triple.isOSBinFormatMachO() && Args.hasArg(options::OPT_static))
-    PIE = PIC = false;
-  bool IsPICLevelTwo = PIC;
+    PIE = pic = false;
+  bool IsPICLevelTwo = pic;
 
   bool KernelOrKext =
       Args.hasArg(options::OPT_mkernel, options::OPT_fapple_kext);
@@ -911,12 +911,12 @@ tools::ParsePICArgs(const ToolChain &Too
     case llvm::Triple::mipsel:
     case llvm::Triple::mips64:
     case llvm::Triple::mips64el:
-      PIC = true; // "-fpic"
+      pic = true; // "-fpic"
       break;
 
     case llvm::Triple::x86:
     case llvm::Triple::x86_64:
-      PIC = true; // "-fPIC"
+      pic = true; // "-fPIC"
       IsPICLevelTwo = true;
       break;
 
@@ -951,7 +951,7 @@ tools::ParsePICArgs(const ToolChain &Too
 
   // AMDGPU-specific defaults for PIC.
   if (Triple.getArch() == llvm::Triple::amdgcn)
-    PIC = true;
+    pic = true;
 
   // The last argument relating to either PIC or PIE wins, and no
   // other argument is used. If the last argument is any flavor of the
@@ -980,17 +980,17 @@ tools::ParsePICArgs(const ToolChain &Too
       if (O.matches(options::OPT_fPIC) || O.matches(options::OPT_fpic) ||
           O.matches(options::OPT_fPIE) || O.matches(options::OPT_fpie)) {
         PIE = O.matches(options::OPT_fPIE) || O.matches(options::OPT_fpie);
-        PIC =
+        pic =
             PIE || O.matches(options::OPT_fPIC) || O.matches(options::OPT_fpic);
         IsPICLevelTwo =
             O.matches(options::OPT_fPIE) || O.matches(options::OPT_fPIC);
       } else {
-        PIE = PIC = false;
+        PIE = pic = false;
         if (EffectiveTriple.isPS4CPU()) {
           Arg *ModelArg = Args.getLastArg(options::OPT_mcmodel_EQ);
           StringRef Model = ModelArg ? ModelArg->getValue() : "";
           if (Model != "kernel") {
-            PIC = true;
+            pic = true;
             ToolChain.getDriver().Diag(diag::warn_drv_ps4_force_pic)
                 << LastPICArg->getSpelling();
           }
@@ -1002,7 +1002,7 @@ tools::ParsePICArgs(const ToolChain &Too
   // Introduce a Darwin and PS4-specific hack. If the default is PIC, but the
   // PIC level would've been set to level 1, force it back to level 2 PIC
   // instead.
-  if (PIC && (Triple.isOSDarwin() || EffectiveTriple.isPS4CPU()))
+  if (pic && (Triple.isOSDarwin() || EffectiveTriple.isPS4CPU()))
     IsPICLevelTwo |= ToolChain.isPICDefault();
 
   // This kernel flags are a trump-card: they will disable PIC/PIE
@@ -1010,7 +1010,7 @@ tools::ParsePICArgs(const ToolChain &Too
   if (KernelOrKext &&
       ((!EffectiveTriple.isiOS() || EffectiveTriple.isOSVersionLT(6)) &&
        !EffectiveTriple.isWatchOS()))
-    PIC = PIE = false;
+    pic = PIE = false;
 
   if (Arg *A = Args.getLastArg(options::OPT_mdynamic_no_pic)) {
     // This is a very special mode. It trumps the other modes, almost no one
@@ -1024,9 +1024,9 @@ tools::ParsePICArgs(const ToolChain &Too
     // Only a forced PIC mode can cause the actual compile to have PIC defines
     // etc., no flags are sufficient. This behavior was selected to closely
     // match that of llvm-gcc and Apple GCC before that.
-    PIC = ToolChain.isPICDefault() && ToolChain.isPICDefaultForced();
+    pic = ToolChain.isPICDefault() && ToolChain.isPICDefaultForced();
 
-    return std::make_tuple(llvm::Reloc::DynamicNoPIC, PIC ? 2U : 0U, false);
+    return std::make_tuple(llvm::Reloc::DynamicNoPIC, pic ? 2U : 0U, false);
   }
 
   bool EmbeddedPISupported;
@@ -1059,7 +1059,7 @@ tools::ParsePICArgs(const ToolChain &Too
   }
 
   // ROPI and RWPI are not compatible with PIC or PIE.
-  if ((ROPI || RWPI) && (PIC || PIE))
+  if ((ROPI || RWPI) && (pic || PIE))
     ToolChain.getDriver().Diag(diag::err_drv_ropi_rwpi_incompatible_with_pic);
 
   if (Triple.isMIPS()) {
@@ -1070,7 +1070,7 @@ tools::ParsePICArgs(const ToolChain &Too
     // when the -mno-abicalls option is used. In that case we exit
     // at next check regardless of PIC being set below.
     if (ABIName == "n64")
-      PIC = true;
+      pic = true;
     // When targettng MIPS with -mno-abicalls, it's always static.
     if(Args.hasArg(options::OPT_mno_abicalls))
       return std::make_tuple(llvm::Reloc::Static, 0U, false);
@@ -1079,7 +1079,7 @@ tools::ParsePICArgs(const ToolChain &Too
     IsPICLevelTwo = false;
   }
 
-  if (PIC)
+  if (pic)
     return std::make_tuple(llvm::Reloc::PIC_, IsPICLevelTwo ? 2U : 1U, PIE);
 
   llvm::Reloc::Model RelocM = llvm::Reloc::Static;
diff -Naupr a/tools/clang/tools/driver/cc1as_main.cpp b/tools/clang/tools/driver/cc1as_main.cpp
--- a/tools/clang/tools/driver/cc1as_main.cpp	2020-03-23 16:01:02.000000000 +0100
+++ b/tools/clang/tools/driver/cc1as_main.cpp	2020-03-29 12:35:09.151573754 +0200
@@ -382,18 +382,18 @@ static bool ExecuteAssembler(AssemblerIn
 
   MCContext Ctx(MAI.get(), MRI.get(), MOFI.get(), &SrcMgr, &MCOptions);
 
-  bool PIC = false;
+  bool pic = false;
   if (Opts.RelocationModel == "static") {
-    PIC = false;
+    pic = false;
   } else if (Opts.RelocationModel == "pic") {
-    PIC = true;
+    pic = true;
   } else {
     assert(Opts.RelocationModel == "dynamic-no-pic" &&
            "Invalid PIC model!");
-    PIC = false;
+    pic = false;
   }
 
-  MOFI->InitMCObjectFileInfo(Triple(Opts.Triple), PIC, Ctx);
+  MOFI->InitMCObjectFileInfo(Triple(Opts.Triple), pic, Ctx);
   if (Opts.SaveTemporaryLabels)
     Ctx.setAllowTemporaryLabels(false);
   if (Opts.GenDwarfForAssembly)
