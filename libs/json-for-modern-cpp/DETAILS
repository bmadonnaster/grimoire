           SPELL=json-for-modern-cpp
         VERSION=3.1.2
          SOURCE="nlohmann-json-${VERSION}.tar.gz"
   SOURCE_URL[0]=https://github.com/nlohmann/json/archive/v${VERSION}.tar.gz
     SOURCE_HASH=sha512:d0a8b968c8fb8cb8f5350f9f3ba78ee26c4b699264f6a52270baaf5c25c0021df1f02b4b0ac99b6e6d46943a92aead613a51f5ebd2155e4f12b74852bbcfd8ef
SOURCE_DIRECTORY="${BUILD_DIRECTORY}/json-${VERSION}"
        WEB_SITE="https://github.com/nlohmann/json"
      LICENSE[0]=MIT
         ENTERED=20180330
           SHORT="a json library for modern C++"
cat << EOF
There are myriads of JSON libraries out there, and each may even have its
reason to exist. Our class had these design goals:

  * Intuitive syntax. In languages such as Python, JSON feels like a first
    class data type. We used all the operator magic of modern C++ to achieve
    the same feeling in your code. Check out the examples below and you'll
    know what I mean.

  * Trivial integration. Our whole code consists of a single header file
    json.hpp. That's it. No library, no subproject, no dependencies, no complex
    build system. The class is written in vanilla C++11. All in all, everything
    should require no adjustment of your compiler flags or project settings.

  * Serious testing. Our class is heavily unit-tested and covers 100% of the
    code, including all exceptional behavior. Furthermore, we checked with
    Valgrind and the Clang Sanitizers that there are no memory leaks. Google
    OSS-Fuzz additionally runs fuzz tests agains all parsers 24/7, effectively
    executing billions of tests so far. To maintain high quality, the project
    is following the Core Infrastructure Initiative (CII) best practices.
EOF
